var md5 = require('md5');
const nodemailer = require('nodemailer');
var pg = require('pg');
pg.defaults.ssl = true;
var uripg ="postgres://qpctvfkpaktrbh:850e3c5962c7eb37c0e7b5b5383a38a0d6c537854dbba0d80052f3ff5b14707a@ec2-54-83-26-65.compute-1.amazonaws.com:5432/dav91uknip05h0";


function makeCode(taille){
  var text = "";
  var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for( var i=0; i < taille; i++ ){
      text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

var champComplet = function(req){
  return("sexe" in req.body
    && "lastname" in req.body
    && "firstname" in req.body
    && "mailadress" in req.body
    && "birthdate" in req.body
    && "password" in req.body
    && "passwordbis" in req.body);
}

var sendMail = function(mailAdress,subject,text,html){
  //Envoie de mail
  console.log("test");
  let transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
          user: 'onamajs@gmail.com',
          pass: 'chocolat74'
      }
  });

  // setup email data with unicode symbols
  let mailOptions = {
      from: '"Onama" <onamajs@gmail.com>', // sender address
      to: mailAdress, // list of receivers
      subject: subject, // Subject line
      text: text, // plain text body
      html: html // html body
  };

  // send mail with defined transport object
  transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
          return console.log(error);
      }
  });
}

var verifInscription = function(req,res,next){
  pg.connect(uripg ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.user where mailadress = $1;",[req.body.mailadress])
      .on("end", function(result) { done();
        if(result.rowCount == 0){
          if(champComplet(req))
          {
            next();
          }
          else {
            res.send({error: 'Des champs sont vides.'});
          }
        }
        else{
          res.send({error: 'Cette adresse mail est déjà utilisée.'});
        }

      });
  });
}

var inscription = function(req, res){
    var newUser = req.body;
    newUser.cookiecode = makeCode(30);
    pg.connect(uripg ,function(err, client, done) {
      if (err) throw err;
      client
        .query("INSERT into public.user (lastname,firstname,mailadress,password,registration,lastconnection,cookiecode,sexe,birthdate,stayconnected)values($1,$2,$3,$4,NOW(),NOW(),$5,$6,$7,false);"
        ,[newUser.lastname, newUser.firstname, newUser.mailadress, md5(newUser.password), newUser.cookiecode, newUser.sexe, newUser.birthdate])
        .on("end", function(result) { done();
          res.send(newUser);
          sendMail(newUser.maladress,"Bienvenue sur Onama !","Salut à toi " + newUser.firstname + " !","<p>Salut à toi " + newUser.firstname + " !</p>")
        });
    });
}

var verifConnection = function(req, res, next){
  pg.connect(uripg ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT password FROM public.user where mailadress = $1;",[req.query.mailadress])
      .on("end", function(result) { done();
        if(result.rowCount != 0 && result.rows[0].password == md5(req.query.password)){
          next();
        }
        else {
          res.send({error: 'Mauvais identifiants'});
        }

      });
  });
}

var addStayConnected = function(req, res, next){
  var stayconnected;
  if(req.query.stayconnected){
    stayconnected = true;
  }
  else {
    stayconnected = false;
  }
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("UPDATE public.user SET stayconnected = $1, lastconnection = NOW() WHERE mailadress = $2;",[stayconnected, req.query.mailadress])
      .on("end", function(result) { done();
        next();

      });
  });
}

var connection = function(req, res, next){
    console.log("connection presque ok");
    pg.connect(uripg, function(err, client, done) {
      if (err) throw err;
      client
        .query("SELECT * FROM public.user where mailadress = $1;",[req.query.mailadress])
        .on('end', function(result) { done();
          res.send(result.rows[0]);

        });
    });
}

var connectionCookie = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.user where cookiecode = $1;",[req.body.cookiecode])
      .on('end', function(result) { done();
        if(result.rowCount == 1){
          res.send(result.rows[0]);
        }
        else {
          res.send({error: 'Probleme de connexion.'});
        }

      });
  });
}

var verifPassword = function(req, res, next){
  var pg = require('pg');
  pg.defaults.ssl = true;
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT password FROM public.user where id_user = $1;",[req.query.id_user])
      .on("end", function(result) { done();

        if(result.rowCount != 0 && result.rows[0].password == md5(req.query.actualpassword)){
          next();
        }
        else {
          res.send({error: 'Mauvais mot de passe.'});
        }
      });
  });
}

var editPassword = function(req, res){
  console.log(md5(req.query.newpassword) + "test" +  req.query.id_user);
  pg.connect(uripg ,function(err, client, done) {
    if (err) throw err;
    client
      .query("UPDATE public.user SET password = $1 WHERE id_user = $2;"
      ,[md5(req.query.newpassword), req.query.id_user])
      .on("end", function(result) { done();

        console.log("alleeeeez");
        res.send({});
      });
  });
}

var insertFood = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("INSERT INTO public.getfood (id_user, id_food, quantity_getfood) VALUES ($1, $2, $3);"
      ,[req.body.id_user, req.body.id_food, req.body.quantity_getfood])
      .on("end", function(result) { done();
        res.send(req.body);

      });
  });
}

var updateFood = function(req, res){
  console.log(req.query.quantity_getfood + "," + req.query.id_user + "," + req.query.id_food);
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("UPDATE public.getfood SET quantity_getfood = $1 WHERE id_user = $2 AND id_food = $3;"
      ,[req.query.quantity_getfood, req.query.id_user, req.query.id_food])
      .on("end", function(result) { done();
        res.send(req.query);

      });
  });
}

var deleteFood = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("DELETE FROM public.getfood WHERE id_user = $1 AND id_food = $2;"
      ,[req.query.id_user, req.query.id_food])
      .on("end", function(result) { done();
        res.send(req.query);

      });
  });
}

var verifMail = function(req, res, next){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.user where mailadress = $1;",[req.query.mailadress])
      .on("end", function(result) { done();
        if(result.rowCount != 0){
          next();
        }
        else {
          res.send({error: 'Adresse mail inexistante.'});

        }
      });
  });
}

var newPassword = function(req, res){
  var newCode = makeCode(10);
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("UPDATE public.user SET password = $1 WHERE mailadress = $2;",[md5(newCode), req.query.mailadress])
      .on("end", function(result) { done();
        if(result.rowCount != 0){
          sendMail(req.query.mailadress,'Nouveau mot de passe','Voici votre nouveau mot de passe : ' + newCode, '<b>Voici votre nouveau mot de passe : ' + newCode + '</b>');
          res.send({mailadress: req.query.mailadress});

        }
        else {
          res.send({error: 'Adresse mail inexistante.'});
        }

      });
  });
}

var getRecipes = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("Select r.id_recipe, r.title_recipe, d.title_difficulty, t.title_type, r.time_recipe, r.popularity, r.peopleamount, o.title_origin, r.description, r.imgurl FROM public.recipe r, public.difficulty d, public.origin o, public.type t WHERE r.id_difficulty = d.id_difficulty AND r.id_origin = o.id_origin AND r.id_type = t.id_type AND id_user = $1;"
      ,[req.query.id_user])
      .on('end', function(result) { done();
        res.send(result.rows);

      });
  });
}

var deleteFood = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query(req.body.reqSql)
      .on('end', function(result) { done();
        res.send({});

      });
  });
}

exports.newPassword = newPassword;
exports.verifMail = verifMail;
exports.deleteFood = deleteFood;
exports.updateFood = updateFood;
exports.editPassword = editPassword;
exports.verifPassword = verifPassword;
exports.addStayConnected = addStayConnected;
exports.verifConnection = verifConnection;
exports.connection = connection;
exports.inscription = inscription;
exports.verifInscription = verifInscription;
exports.connectionCookie = connectionCookie;
exports.insertFood = insertFood;
exports.getRecipes = getRecipes;
exports.deleteFood = deleteFood;
