var pg = require('pg');
pg.defaults.ssl = true;
var uripg ="postgres://qpctvfkpaktrbh:850e3c5962c7eb37c0e7b5b5383a38a0d6c537854dbba0d80052f3ff5b14707a@ec2-54-83-26-65.compute-1.amazonaws.com:5432/dav91uknip05h0";

var getAll = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("Select r.id_recipe, r.title_recipe, d.title_difficulty, t.title_type, r.time_recipe, r.popularity, r.peopleamount, o.title_origin, r.description, r.imgurl FROM public.recipe r, public.difficulty d, public.origin o, public.type t WHERE r.id_difficulty = d.id_difficulty AND r.id_origin = o.id_origin AND r.id_type = t.id_type LIMIT 15;")
      .on("end", function(result) { done();
        res.send(result.rows);

      });
  });
}

var getTypes = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.type;")
      .on('end', function(result) { done();
        res.send(result.rows);

      });
  });
}

var getDifficulties = function(req,res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.difficulty;")
      .on('end', function(result) { done();
        res.send(result.rows);

      });
  });
}

var getOrigins = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.origin ORDER BY title_origin;")
      .on('end', function(result) { done();
        res.send(result.rows);

      });
  });
}

var addRecipe = function(req, res ,next){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("INSERT INTO public.recipe (title_recipe, description, time_recipe, popularity, peopleamount, imgurl, id_difficulty, id_type, id_origin, id_user)VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING id_recipe;"
      ,[req.body.title_recipe, req.body.description, req.body.time_recipe, 0, req.body.peopleamount, req.body.imgurl, req.body.id_difficulty, req.body.id_type, req.body.id_origin, req.body.id_user])
      .on('end', function(result) { done();
        console.log(result.rows[0].id_recipe);
        req.body.id_recipe = result.rows[0].id_recipe;
        next();
      });
  });
}

var verifAddRecipe = function(req, res, next){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT * FROM public.recipe WHERE title_recipe = $1 ;", [req.body.title_recipe])
      .on('end', function(result) { done();
        if(result.rows.length > 0){
          res.send({error: "Nom déjà utilisé"});
        }
        else {
          next();
        }

      });
  });
}

var addInstructions = function(req, next){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    for(var i = 0; i < req.body.instructions.length; i++){
      client
        .query("INSERT INTO public.instructions (id_recipe, title_instruction) VALUES ($1, $2);", [req.body.id_recipe, req.body.instructions[i]])
        .on('end', function(result) { done();
          ///
        });
      }
      next();
  });
}

var addFood = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    for(var i = 0; i < req.body.food.length; i++){
      client
        .query("INSERT INTO public.containfood (id_recipe, id_food, quantity_containfood) VALUES ($1, $2, $3);"
        , [req.body.id_recipe, req.body.food[i].id_food, req.body.food[i].quantity_containfood])
        .on('end', function(result) { done();
          ///
        });
    }
    res.send(req.body);
  });
}

var getOne = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("SELECT r.title_recipe, r.time_recipe, r.description, d.title_difficulty, r.popularity, r.peopleamount, r.imgurl, t.title_type, o.title_origin, d.title_difficulty, i.title_instruction, f.title_food, c.quantity_containfood, f.price, f.calorie, f.proteins, f.lipids, f.carbohydrates FROM public.recipe r, public.instructions i, public.containfood c, public.food f, public.difficulty d, public.origin o, public.type t WHERE r.id_recipe = i.id_recipe AND r.id_recipe = c.id_recipe AND c.id_food = f.id_food AND r.id_difficulty = d.id_difficulty AND r.id_origin = o.id_origin AND r.id_type = t.id_type AND r.id_recipe = $1;"
      , [req.query.id_recipe])
      .on('end', function(result) { done();
        var recipe = {};
        var instructions = [];
        var food = [];
        var title_food_Arr = [];
        var quantity_containfood_Arr = [];
        var row = {};
        var price = 0;
        var calorie = 0;
        var proteins = 0;
        var lipids = 0;
        var carbohydrates = 0;
        var quantityTotal = 0;

        result.rows.forEach(function(row){
          if(instructions.indexOf(row.title_instruction) == -1){
            instructions.push(row.title_instruction);
          }
          if(title_food_Arr.indexOf(row.title_food) == -1){
            title_food_Arr.push(row.title_food);
            quantity_containfood_Arr.push(row.quantity_containfood);
            price += row.price*row.quantity_containfood/1000;
            calorie += row.calorie*row.quantity_containfood/100;
            proteins += row.proteins*row.quantity_containfood/100;
            lipids += row.lipids*row.quantity_containfood/100;
            carbohydrates += row.carbohydrates*row.quantity_containfood/100;
            quantityTotal += row.quantity_containfood;
          }
        });

        for(var i = 0; i < title_food_Arr.length; i++){
          food.push({title_food: title_food_Arr[i], quantity_containfood: quantity_containfood_Arr[i]});
        }
        if(result.rowCount == 0){
          res.send({error: "Recette inexistante."});
        }
        else {
          var row1 = result.rows[0];
          recipe = {
            id_recipe: req.query.id_recipe,
            title_recipe: row1.title_recipe,
            time_recipe : row1.time_recipe,
            description: row1.description,
            title_difficulty: row1.title_difficulty,
            popularity: row1.popularity,
            peopleamount: row1.peopleamount,
            imgurl: row1.imgurl,
            title_type: row1.title_type,
            title_origin: row1.title_origin,
            title_difficulty: row1.title_difficulty,
            instructions: instructions,
            food: food,
            price: price,
            calorie: calorie/(quantityTotal/100),
            proteins: proteins/(quantityTotal/100),
            lipids: lipids/(quantityTotal/100),
            carbohydrates: carbohydrates/(quantityTotal/100),
            totalQuantity: quantityTotal
          }
          res.send(recipe);
        }
      });
  });
}

var deleteRecipe = function(req, res){
  pg.connect(uripg  ,function(err, client, done) {
    if (err) throw err;
    client
      .query("DELETE FROM public.recipe where id_recipe = $1;"
      , [req.params.id_recipe])
      .on('end', function(result) { done();
        ///
      });
    res.send({});
  });
}

exports.deleteRecipe = deleteRecipe;
exports.getOne = getOne;
exports.addFood = addFood;
exports.addInstructions = addInstructions;
exports.verifAddRecipe = verifAddRecipe;
exports.addRecipe = addRecipe;
exports.getOrigins = getOrigins;
exports.getDifficulties = getDifficulties;
exports.getTypes = getTypes;
exports.getAll = getAll;
